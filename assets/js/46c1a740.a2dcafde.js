"use strict";(self.webpackChunksinnammanyo_cn=self.webpackChunksinnammanyo_cn||[]).push([[1144],{10657:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>_,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>d});var i=t(87462),s=(t(67294),t(3905));t(83989);const r={id:"esp32-demo-tcp-server",title:"",sidebar_label:"Tcp Server"},_="ESP32 Demo Tcp Server",a={unversionedId:"devices/esp32/wifi/esp32-demo-tcp-server",id:"devices/esp32/wifi/esp32-demo-tcp-server",title:"",description:"name | version",source:"@site/docs/stack/devices/esp32/wifi/esp32-demo-tcp-server.md",sourceDirName:"devices/esp32/wifi",slug:"/devices/esp32/wifi/esp32-demo-tcp-server",permalink:"/stack/devices/esp32/wifi/esp32-demo-tcp-server",draft:!1,editUrl:"https://github.com/rcxxx/sinnammanyo.cn/tree/master/docs/stack/devices/esp32/wifi/esp32-demo-tcp-server.md",tags:[],version:"current",frontMatter:{id:"esp32-demo-tcp-server",title:"",sidebar_label:"Tcp Server"},sidebar:"\ud83d\udda5\ufe0fdevices&system",previous:{title:"Demo Wifi",permalink:"/stack/devices/esp32/wifi/esp32-demo-wifi"},next:{title:"system",permalink:"/stack/category/system"}},o={},d=[{value:"Wi-Fi connect",id:"wi-fi-connect",level:2},{value:"TCP server on lwIP socket",id:"tcp-server-on-lwip-socket",level:2},{value:"TCP server IPV4",id:"tcp-server-ipv4",level:2},{value:"recv / send Loop",id:"recv--send-loop",level:3},{value:"TCP server task",id:"tcp-server-task",level:3},{value:"\u5b8c\u6574\u4ee3\u7801",id:"\u5b8c\u6574\u4ee3\u7801",level:3},{value:"\u53c2\u8003",id:"\u53c2\u8003",level:2}],c={toc:d};function l(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,i.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"esp32-demo-tcp-server"},"ESP32 Demo Tcp Server"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"name"),(0,s.kt)("th",{parentName:"tr",align:"center"},"version"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"System"),(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"https://releases.ubuntu.com/20.04/"},"Ubuntu 20.04")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"CMake"),(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"https://cmake.org/"},"3.10"))," \u2265")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"ESP-IDF"),(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"https://github.com/espressif/esp-idf"},"master--v5.1")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"ESP-IDF Programming GuideLogo"),(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("strong",{parentName:"td"},(0,s.kt)("a",{parentName:"strong",href:"https://docs.espressif.com/projects/esp-idf/en/release-v5.1/esp32/index.html"},"v5.1")))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},"Device"),(0,s.kt)("td",{parentName:"tr",align:"center"},"ESP32-S3-WROOM-1")))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"\u521b\u5efa\u7a7a\u9879\u76ee")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\u6fc0\u6d3b\u73af\u5883")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},". ~/esp/esp-idf/export.sh \n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\u521b\u5efa\u9879\u76ee")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"idf.py create-project ${project_name}\n")),(0,s.kt)("p",null,"\u5173\u4e8e\u9879\u76ee ",(0,s.kt)("inlineCode",{parentName:"p"},"CMake")," \u7684\u914d\u7f6e\u53ef\u4ee5\u53c2\u7167"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},(0,s.kt)("a",{parentName:"em",href:"https://sinnammanyo.cn/stack/devices/esp32/esp32-idf-Clion-env"},"\u5728 CLion \u4e2d\u914d\u7f6e ESP_CMake \u9879\u76ee")))),(0,s.kt)("h2",{id:"wi-fi-connect"},"Wi-Fi connect"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"wifi_init_sta();\n")),(0,s.kt)("p",null,"\u8fde\u63a5 Wi-Fi \u6210\u529f\u540e\u5c06\u5f97\u5230\u76f8\u5e94\u7684 ip \u5730\u5740\uff0c\u4f5c\u4e3a\u540e\u7eed TCP Server \u7684 ip \u5730\u5740"),(0,s.kt)("h2",{id:"tcp-server-on-lwip-socket"},"TCP server on lwIP socket"),(0,s.kt)("h2",{id:"tcp-server-ipv4"},"TCP server IPV4"),(0,s.kt)("h3",{id:"recv--send-loop"},"recv / send Loop"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"// \u63a5\u6536\nstatic inline ssize_t recv(int s,void *mem,size_t len,int flags)\n{ return lwip_recv(s,mem,len,flags); }\n\n// \u53d1\u9001\nstatic inline ssize_t send(int s,const void *dataptr,size_t size,int flags)\n{ return lwip_send(s,dataptr,size,flags); }\n")),(0,s.kt)("h3",{id:"tcp-server-task"},"TCP server task"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"// \u521b\u5efa\nstatic inline int socket(int domain,int type,int protocol)\n{ return lwip_socket(domain,type,protocol); }\n\n// \u7ed1\u5b9a\nstatic inline int bind(int s,const struct sockaddr *name, socklen_t namelen)\n{ return lwip_bind(s,name,namelen); }\n\n// \u76d1\u542c\nstatic inline int listen(int s,int backlog)\n{ return lwip_listen(s,backlog); }\n\n// \u8ba4\u8bc1\nstatic inline int accept(int s,struct sockaddr *addr,socklen_t *addrlen)\n{ return lwip_accept(s,addr,addrlen); }\n\n// \u5173\u95ed\nstatic inline int shutdown(int s,int how)\n{ return lwip_shutdown(s,how); }\n\nint     close (int __fildes);\n")),(0,s.kt)("h3",{id:"\u5b8c\u6574\u4ee3\u7801"},"\u5b8c\u6574\u4ee3\u7801"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <string.h>\n#include <sys/param.h>\n\n#include "freertos/FreeRTOS.h"\n#include "freertos/task.h"\n#include "freertos/event_groups.h"\n\n#include "esp_system.h"\n#include "esp_wifi.h"\n#include "esp_event.h"\n#include "esp_log.h"\n#include "esp_netif.h"\n#include "nvs_flash.h"\n\n#include "lwip/err.h"\n#include "lwip/sockets.h"\n#include "lwip/sys.h"\n#include <lwip/netdb.h>\n\n/*---wifi---*/\n#define ESP_WIFI_SSID       "ssid"\n#define ESP_WIFI_PASS       "password"\n#define ESP_MAXIMUM_RETRY   5\n#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA2_PSK\n\nstatic EventGroupHandle_t s_wifi_event_group;\n\n#define WIFI_CONNECTED_BIT  BIT0\n#define WIFI_FAIL_BIT       BIT1\n\nstatic const char* WIFI_TAG = "wifi station";\nstatic int s_retry_num = 0;\n\nstatic void wifi_event_handler(void* arg, esp_event_base_t event_base,\n                          int32_t event_id, void* event_data)\n{\n    if(event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {\n        esp_wifi_connect();\n    } else if(event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {\n        if(s_retry_num < ESP_MAXIMUM_RETRY) {\n            esp_wifi_connect();\n            s_retry_num++;\n            ESP_LOGI(WIFI_TAG, "retry to connect to the AP");\n        } else {\n            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);\n        }\n        ESP_LOGI(WIFI_TAG,"connect to the AP fail");\n    } else if(event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {\n        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;\n        ESP_LOGI(WIFI_TAG, "got ip:" IPSTR, IP2STR(&event->ip_info.ip));\n        s_retry_num = 0;\n        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);\n    }\n}\n\nvoid wifi_init_sta(void)\n{\n    s_wifi_event_group = xEventGroupCreate();\n\n    ESP_ERROR_CHECK(esp_netif_init());\n\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\n    esp_netif_create_default_wifi_sta();\n\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\n    ESP_ERROR_CHECK(esp_wifi_init(&cfg));\n\n    esp_event_handler_instance_t instance_any_id;\n    esp_event_handler_instance_t instance_got_ip;\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,\n                                                        ESP_EVENT_ANY_ID,\n                                                        &wifi_event_handler,\n                                                        NULL,\n                                                        &instance_any_id));\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,\n                                                        IP_EVENT_STA_GOT_IP,\n                                                        &wifi_event_handler,\n                                                        NULL,\n                                                        &instance_got_ip));\n\n    wifi_config_t wifi_config = {\n            .sta = {\n                    .ssid = ESP_WIFI_SSID,\n                    .password = ESP_WIFI_PASS,\n                    .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,\n                    .sae_pwe_h2e = WPA3_SAE_PWE_BOTH,\n            },\n    };\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config) );\n    ESP_ERROR_CHECK(esp_wifi_start() );\n\n    ESP_LOGI(WIFI_TAG, "wifi_init_sta finished.");\n\n    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,\n                                           WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,\n                                           pdFALSE,\n                                           pdFALSE,\n                                           portMAX_DELAY);\n\n    if (bits & WIFI_CONNECTED_BIT) {\n        ESP_LOGI(WIFI_TAG, "connected to ap SSID:%s password:%s",\n                 ESP_WIFI_SSID, ESP_WIFI_PASS);\n    } else if (bits & WIFI_FAIL_BIT) {\n        ESP_LOGI(WIFI_TAG, "Failed to connect to SSID:%s, password:%s",\n                 ESP_WIFI_SSID, ESP_WIFI_PASS);\n    } else {\n        ESP_LOGE(WIFI_TAG, "UNEXPECTED EVENT");\n    }\n}\n/*---wifi---*/\n\n/*---Tcp---*/\n#define PORT                        1234\n#define KEEPALIVE_IDLE              5\n#define KEEPALIVE_INTERVAL          5\n#define KEEPALIVE_COUNT             3\n\nstatic const char* TCP_TAG = "TCP Server";\n\nstatic void do_retransmit(const int sock)\n{\n    int len;\n    char rx_buffer[128];\n\n    do {\n        len = recv(sock, rx_buffer, sizeof(rx_buffer) - 1,0);\n        if (len < 0){\n            ESP_LOGE(TCP_TAG, "Error occurred during receiving: errno %d", errno);\n        } else if (len == 0) {\n            ESP_LOGW(TCP_TAG, "Connection closed");\n        } else {\n            rx_buffer[len] = 0; // \u63a5\u6536\u5230\u7684\u5185\u5bb9 + \'\\0\' \u5e76\u89c6\u4e3a\u5b57\u7b26\u4e32\n            ESP_LOGI(TCP_TAG, "Received %d bytes: %s", len, rx_buffer);\n\n            int to_write = len;\n            while (to_write > 0) {\n                int written = send(sock, rx_buffer + (len - to_write), to_write, 0);\n                if (written < 0) {\n                    ESP_LOGE(TCP_TAG, "Error occurred during sending: errno %d", errno);\n                    // \u56de\u53d1\u5931\u8d25\n                    return;\n                }\n                to_write -= written;\n            }\n        }\n    } while (len > 0);\n}\n\nstatic void tcp_server_task(void *pvParameters)\n{\n    char addr_str[128];\n    int addr_family = (int)pvParameters;\n    int ip_protocol = 0;\n    int keepAlive = 1;\n    int keepIdle = KEEPALIVE_IDLE;\n    int keepInterval = KEEPALIVE_INTERVAL;\n    int keepCount = KEEPALIVE_COUNT;\n    struct sockaddr_storage dest_addr;\n\n    if (addr_family == AF_INET) {\n        struct sockaddr_in *dest_addr_ip4 = (struct sockaddr_in *)&dest_addr;\n        dest_addr_ip4->sin_addr.s_addr = htonl(INADDR_ANY);\n        dest_addr_ip4->sin_family = AF_INET;\n        dest_addr_ip4->sin_port = htons(PORT);\n        ip_protocol = IPPROTO_IP;\n    }\n\n    int listen_sock = socket(addr_family, SOCK_STREAM, ip_protocol);\n    if (listen_sock < 0) {\n        ESP_LOGE(TCP_TAG, "Unable to create socket: errno %d", errno);\n        vTaskDelete(NULL);\n        return;\n    }\n    int opt = 1;\n    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    ESP_LOGI(TCP_TAG, "Socket created");\n\n    int err = bind(listen_sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr));\n    if (err != 0) {\n        ESP_LOGE(TCP_TAG, "Socket unable to bind: errno %d", errno);\n        ESP_LOGE(TCP_TAG, "IPPROTO: %d", addr_family);\n        close(listen_sock);\n        vTaskDelete(NULL);\n    }\n    ESP_LOGI(TCP_TAG, "Socket bound, port %d", PORT);\n\n    err = listen(listen_sock, 1);\n    if (err != 0) {\n        ESP_LOGE(TCP_TAG, "Error occurred during listen: errno %d", errno);\n        close(listen_sock);\n        vTaskDelete(NULL);\n    }\n\n    while (1) {\n        ESP_LOGI(TCP_TAG, "Socket listening");\n        struct sockaddr_storage source_addr;\n        socklen_t addr_len = sizeof(source_addr);\n\n        int sock = accept(listen_sock, (struct sockaddr *)&source_addr, &addr_len);\n        if (sock < 0) {\n            ESP_LOGE(TCP_TAG, "Unable to accept connection: errno %d", errno);\n            break;\n        }\n\n        // Set tcp keepalive option\n        setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &keepAlive, sizeof(int));\n        setsockopt(sock, IPPROTO_TCP, TCP_KEEPIDLE, &keepIdle, sizeof(int));\n        setsockopt(sock, IPPROTO_TCP, TCP_KEEPINTVL, &keepInterval, sizeof(int));\n        setsockopt(sock, IPPROTO_TCP, TCP_KEEPCNT, &keepCount, sizeof(int));\n\n        // Convert ip address to string\n        if (source_addr.ss_family == PF_INET) {\n            inet_ntoa_r(((struct sockaddr_in *)&source_addr)->sin_addr, addr_str, sizeof(addr_str) - 1);\n        }\n        ESP_LOGI(TCP_TAG, "Socket accepted ip address: %s", addr_str);\n\n        do_retransmit(sock);\n\n        shutdown(sock, 0);\n        close(sock);\n    }\n\n    close(listen_sock);\n    vTaskDelete(NULL);\n}\n/*---Tcp---*/\n\nvoid app_main(void)\n{\n    esp_err_t ret = nvs_flash_init();\n    if(ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND){\n        ESP_ERROR_CHECK(nvs_flash_erase());\n        ret = nvs_flash_init();\n    }\n    ESP_ERROR_CHECK(ret);\n\n    ESP_LOGI(WIFI_TAG, "ESP_WIFI_MODE_STA");\n    wifi_init_sta();\n\n    xTaskCreate(tcp_server_task, "tcp_server", 4096, (void*)AF_INET, 5, NULL);\n}\n')),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"\u6267\u884c\u7ed3\u679c")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://pictures-1304295136.cos.ap-guangzhou.myqcloud.com/screenshot/esp32/wifi-tcp/tcp-server-result.png",alt:null})),(0,s.kt)("h2",{id:"\u53c2\u8003"},"\u53c2\u8003"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},(0,s.kt)("a",{parentName:"strong",href:"https://www.bilibili.com/video/BV1kG411E7DR/?spm_id_from=333.788&vd_source=4cca3a7520260c460d94cf70a3f0a5ba"},"ESP32 WIFI\u6559\u7a0b\u4e94: TCP\u670d\u52a1\u7aef")))))}l.isMDXComponent=!0}}]);